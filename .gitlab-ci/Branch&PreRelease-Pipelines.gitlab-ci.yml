#############################################################################
## FEATURE COMMITS, 'DEVELOP' TARGETED PULL REQUESTS, PRE-RELEASE TAGS
#############################################################################

# https://gitlab.com/gitlab-org/gitlab/-/issues/206960
# https://docs.gitlab.com/ee/ci/jobs/job_control.html#cicd-variable-expressions
.default_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_BRANCH &&
        $CI_COMMIT_BRANCH != "main" &&
        $CI_COMMIT_BRANCH != "develop" &&
        $CI_PIPELINE_SOURCE != "external_pull_request_event"
    - if: $CI_COMMIT_TAG
      when: never

.default_db_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_BRANCH &&
        $CI_COMMIT_BRANCH != "main" &&
        $CI_COMMIT_BRANCH != "develop" &&
        $CI_PIPELINE_SOURCE != "external_pull_request_event"
      changes:
        - database/*
    - if: $CI_COMMIT_TAG
      when: never

.develop_pr_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_TAG
      when: never

.develop_pr_manual_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
      when: manual
    - if: $CI_COMMIT_TAG
      when: never

.develop_commit_rules:
  rules:
    - if: $CI_COMMIT_BRANCH &&
        $CI_COMMIT_BRANCH == "develop" &&
        $CI_PIPELINE_SOURCE != "external_pull_request_event"
    - if: $CI_COMMIT_TAG
      when: never

.pre-release_rules:
  rules:
    - if: $CI_COMMIT_TAG =~ /^(?<MAJOR>(?:0|(?:[1-9]\d*)))\.(?<MINOR>(?:0|(?:[1-9]\d*)))\.(?<PATCH>(?:0|(?:[1-9]\d*)))(?:-(?<prerelease>(alpha|beta|rc)((\.)?(\d+))?))$/


check-default-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  script:
    - echo ${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}
    - echo ${CI_COMMIT_TAG}
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "develop" ];
      then echo "external pull request target branch is 'develop'";
      else echo "external pull request target branch '${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}' != 'develop'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "develop" ];
      then echo "external pull request target branch is not 'develop'";
      else echo "external pull request target branch '${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}' == 'develop'"; fi
    - echo ${CI_COMMIT_BRANCH}
    - echo ${CI_PIPELINE_SOURCE}
    - echo ${CI_COMMIT_TAG}
    - if [ -n "${CI_COMMIT_BRANCH}" ];
      then echo "commit branch string length is nonzero";
      else echo "commit branch = '${CI_COMMIT_BRANCH}'"; fi
    - if [ -z "${CI_COMMIT_BRANCH}" ];
      then echo "commit branch string length is zero";
      else echo "commit branch = '${CI_COMMIT_BRANCH}'"; fi
    - if [ "${CI_COMMIT_BRANCH}" != "main" ];
      then echo "commit branch is not 'main'";
      else echo "'${CI_COMMIT_BRANCH}' == 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" = "main" ];
      then echo "commit branch is 'main'";
      else echo "'${CI_COMMIT_BRANCH}' != 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" != "develop" ];
      then echo "commit branch is not 'develop'";
      else echo "'${CI_COMMIT_BRANCH}' == 'develop'"; fi
    - if [ "${CI_COMMIT_BRANCH}" = "develop" ];
      then echo "commit branch is 'develop'";
      else echo "'${CI_COMMIT_BRANCH}' != 'develop'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ];
      then echo "pipeline source is not 'external_pull_request_event'";
      else echo "'${CI_PIPELINE_SOURCE}' == 'external_pull_request_event'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" = "external_pull_request_event" ];
      then echo "pipeline source is 'external_pull_request_event'" ;
      else echo "'${CI_PIPELINE_SOURCE}' != 'external_pull_request_event'"; fi
    - if [ -n "${CI_COMMIT_BRANCH}" ] &&
        [ "${CI_COMMIT_BRANCH}" != "main" ] &&
        [ "${CI_COMMIT_BRANCH}" != "develop" ] &&
        [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ];
      then echo "commit branch exists, isn't 'main', isn't 'develop', and it's not an external pull request";
      else echo "commit branch = '${CI_COMMIT_BRANCH}', pipeline source = '${CI_PIPELINE_SOURCE}'"; fi
    - if [ -z "${CI_COMMIT_BRANCH}" ] ||
        [ "${CI_COMMIT_BRANCH}" = "main" ] ||
        [ "${CI_COMMIT_BRANCH}" = "develop" ] ||
        [ "${CI_PIPELINE_SOURCE}" = "external_pull_request_event" ];
      then echo "commit branch doesn't exist or is 'main' or is 'develop' or it's an external pull request";
      else echo "commit branch = '${CI_COMMIT_BRANCH}', pipeline source = '${CI_PIPELINE_SOURCE}'"; fi
    - if [ -z "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi
    - if [ -n "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi

check-develop-pr-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .develop_pr_rules, rules ]
  script:
    - echo "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}"
    - echo "${CI_COMMIT_TAG}"
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "develop" ];
      then echo "external pull request target branch is 'develop'";
      else echo "external pull request target branch '${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}' != 'develop'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "develop" ];
      then echo "external pull request target branch is not 'develop'";
      else echo "external pull request target branch '${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}' == 'develop'"; fi
    - if [ -z "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi
    - if [ -n "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi

check-develop-commit-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  script:
    - echo ${CI_COMMIT_BRANCH}
    - echo ${CI_PIPELINE_SOURCE}
    - echo ${CI_COMMIT_TAG}
    - if [ -n "${CI_COMMIT_BRANCH}" ];
      then echo "commit branch string length is nonzero";
      else echo "commit branch = '${CI_COMMIT_BRANCH}'"; fi
    - if [ -z "${CI_COMMIT_BRANCH}" ];
      then echo "commit branch string length is zero";
      else echo "commit branch = '${CI_COMMIT_BRANCH}'"; fi
    - if [ "${CI_COMMIT_BRANCH}" = "develop" ];
      then echo "commit branch is 'develop'";
      else echo "'${CI_COMMIT_BRANCH}' != 'develop'"; fi
    - if [ "${CI_COMMIT_BRANCH}" != "develop" ];
      then echo "commit branch is not 'develop'";
      else echo "'${CI_COMMIT_BRANCH}' == 'develop'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ];
      then echo "pipeline source is not 'external_pull_request_event'";
      else echo "'${CI_PIPELINE_SOURCE}' == 'external_pull_request_event'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" = "external_pull_request_event" ];
      then echo "pipeline source is 'external_pull_request_event'";
      else echo "'${CI_PIPELINE_SOURCE}' != 'external_pull_request_event'"; fi
    - if [ -n "${CI_COMMIT_BRANCH}" ] &&
        [ "${CI_COMMIT_BRANCH}" = "develop" ] &&
        [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ];
      then echo "commit branch exists, is 'develop', and it's not an external pull request";
      else echo "commit branch = '${CI_COMMIT_BRANCH}', pipeline source = '${CI_PIPELINE_SOURCE}'"; fi
    - if [ -z "${CI_COMMIT_BRANCH}" ] ||
        [ "${CI_COMMIT_BRANCH}" != "develop" ] ||
        [ "${CI_PIPELINE_SOURCE}" = "external_pull_request_event" ];
      then echo "commit branch doesn't exist or isn't 'develop' or it's an external pull request";
      else echo "commit branch = '${CI_COMMIT_BRANCH}', pipeline source = '${CI_PIPELINE_SOURCE}'"; fi
    - if [ -z "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi
    - if [ -n "${CI_COMMIT_TAG}" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '${CI_COMMIT_TAG}'"; fi

check-pre-release-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .pre-release_rules, rules ]
  before_script:
    - PRERELEASE_REGEX="^(0|([1-9][0-9]*))\.(0|([1-9][0-9]*))\.(0|([1-9][0-9]*))(-((alpha|beta|rc)((\.)?([0-9]+))?))$"
  script:
    - echo ${PRERELEASE_REGEX}
    - if [[ ${CI_COMMIT_TAG} =~ ${PRERELEASE_REGEX} ]];
      then echo "${CI_COMMIT_TAG} is a valid pre-release tag.";
      else echo "${CI_COMMIT_TAG} is not a valid pre-release tag!"; fi

install-dependencies:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_rules, rules ]
  needs: []
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules
      - .npm/
  script:
    - npm ci --cache .npm --prefer-offline --no-fund
  artifacts:
    paths:
      - node_modules

build-cicd-base-image:
  stage: build
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
      changes:
        - .gitlab-ci/CICD.Dockerfile
    - if: $CI_COMMIT_BRANCH &&
        $CI_COMMIT_BRANCH != "main" &&
        $CI_COMMIT_BRANCH != "develop" &&
        $CI_PIPELINE_SOURCE != "external_pull_request_event"
      changes:
        - .gitlab-ci.yml
        - .gitlab-ci/CICD.Dockerfile
    - if: $CI_COMMIT_TAG
      when: never
  needs: []
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${REGISTRY_PASSWORD}" | docker login -u ${REGISTRY_USER} --password-stdin ${REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE=${BASE_IMAGE}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
          --file .gitlab-ci/CICD.Dockerfile
          --tag ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
        .
    - docker push -q ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${REGISTRY}

.distributed:
  interruptible: true
  rules:
    - !reference [ .default_rules, rules ]
  needs:
    - install-dependencies
  artifacts:
    paths:
      - node_modules/.cache/nx

build-db-image:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-db"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${REGISTRY_PASSWORD}" | docker login -u ${REGISTRY_USER} --password-stdin ${REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${DB_IMAGE_NAME}:latest
          --file database/Postgres.Dockerfile
          --tag ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${DB_IMAGE_NAME}:latest
        .
    - docker push -q -a ${DB_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${REGISTRY}

build-liquibase-image:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-liquibase"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${REGISTRY_PASSWORD}" | docker login -u ${REGISTRY_USER} --password-stdin ${REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${LIQUIBASE_IMAGE_NAME}:latest
          --file database/Liquibase.Dockerfile
          --tag ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${LIQUIBASE_IMAGE_NAME}:latest
        .
    - docker push -q -a ${LIQUIBASE_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${REGISTRY}

build-app:
  stage: build
  interruptible: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=build --parallel=3
  artifacts:
    paths:
      - dist

test-db:
  stage: test-db
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  needs:
    - build-db-image
    - build-liquibase-image
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.coding-box.template
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.coding-box.template
    - echo "${REGISTRY_PASSWORD}" | docker login -u ${REGISTRY_USER} --password-stdin ${REGISTRY}
    - docker network create app-net
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        pull --quiet db liquibase
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        up -d db
    - export $(grep -v '^#' .env.coding-box.template | xargs)
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        run --rm liquibase
          liquibase
              --changelogFile coding-box.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            status
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        run --rm liquibase
          liquibase
              --changelogFile coding-box.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            validate
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        run --rm liquibase
          liquibase
              --changelogFile coding-box.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            updateSQL
  script:
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        run --rm liquibase
          liquibase
              --changelogFile coding-box.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            updateTestingRollback
    - docker compose
          --file docker-compose.coding-box.yaml
          --file docker-compose.coding-box.prod.yaml
          --env-file .env.coding-box.template
        run --rm liquibase
          liquibase
              --changelogFile coding-box.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            history

test-app:
  stage: test-units
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=test --parallel=2

lint-app:
  stage: lint
  extends: .distributed
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=lint --parallel=2

audit-app:
  stage: audit
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  needs:
    - install-dependencies
  script:
    - npm audit --audit-level critical

build-develop-commit-db-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-db"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${DB_IMAGE_NAME}:latest
          --file database/Postgres.Dockerfile
          --tag ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${DB_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${DB_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${CI_REGISTRY}

build-develop-commit-liquibase-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-liquibase"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${LIQUIBASE_IMAGE_NAME}:latest
          --file database/Liquibase.Dockerfile
          --tag ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${LIQUIBASE_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${LIQUIBASE_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${CI_REGISTRY}

build-develop-commit-base-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-base"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --tag ${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${BASE_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${BASE_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${CI_REGISTRY}

build-develop-commit-backend-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-base-image
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-base"
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-backend"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --target=prod
          --build-arg PROJECT=backend
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE_NAME=${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${BACKEND_IMAGE_NAME}:latest
          --file apps/backend/Dockerfile
          --tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          --tag ${BACKEND_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${BACKEND_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${CI_REGISTRY}

build-develop-commit-frontend-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-base-image
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-base"
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-frontend"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u ${CI_DEPENDENCY_PROXY_USER} -p ${CI_DEPENDENCY_PROXY_PASSWORD} ${CI_DEPENDENCY_PROXY_SERVER}
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
  script:
    - docker build
          --progress plain
          --pull
          --target=prod
          --build-arg PROJECT=frontend
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE_NAME=${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${FRONTEND_IMAGE_NAME}:latest
          -f apps/frontend/Dockerfile
          -t ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${FRONTEND_IMAGE_NAME}:latest
        .
    - docker push --quiet --all-tags ${FRONTEND_IMAGE_NAME}
  after_script:
    - docker logout ${CI_DEPENDENCY_PROXY_SERVER}
    - docker logout ${CI_REGISTRY}

scan-develop-commit-db-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-db-image
  image:
    name: ${TRIVY_IMAGE}
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "${CI_REGISTRY_USER}"
    TRIVY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
    TRIVY_AUTH_URL: "${CI_REGISTRY}"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-db:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir ${CI_PROJECT_DIR}, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "${CI_PROJECT_DIR}/gl-container-scanning-report.json"
        "${FULL_IMAGE_NAME}"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "${FULL_IMAGE_NAME}"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        ${FULL_IMAGE_NAME}
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-liquibase-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-liquibase-image
  image:
    name: ${TRIVY_IMAGE}
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "${CI_REGISTRY_USER}"
    TRIVY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
    TRIVY_AUTH_URL: "${CI_REGISTRY}"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-liquibase:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir ${CI_PROJECT_DIR}, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "${CI_PROJECT_DIR}/gl-container-scanning-report.json"
        "${FULL_IMAGE_NAME}"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "${FULL_IMAGE_NAME}"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "${FULL_IMAGE_NAME}"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-backend-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-backend-image
  image:
    name: ${TRIVY_IMAGE}
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "${CI_REGISTRY_USER}"
    TRIVY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
    TRIVY_AUTH_URL: "${CI_REGISTRY}"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-backend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir ${CI_PROJECT_DIR}, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "${CI_PROJECT_DIR}/gl-container-scanning-report.json"
        "${FULL_IMAGE_NAME}"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "${FULL_IMAGE_NAME}"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "${FULL_IMAGE_NAME}"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-frontend-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-frontend-image
  image:
    name: ${TRIVY_IMAGE}
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "${CI_REGISTRY_USER}"
    TRIVY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
    TRIVY_AUTH_URL: "${CI_REGISTRY}"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-frontend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir ${CI_PROJECT_DIR}, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "${CI_PROJECT_DIR}/gl-container-scanning-report.json"
        "${FULL_IMAGE_NAME}"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "${FULL_IMAGE_NAME}"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "${FULL_IMAGE_NAME}"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-traefik-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-frontend-image
  image:
    name: ${TRIVY_IMAGE}
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "${CI_REGISTRY_USER}"
    TRIVY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
    TRIVY_AUTH_URL: "${CI_REGISTRY}"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${TRAEFIK_BASE_IMAGE}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir ${CI_PROJECT_DIR}, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "${CI_PROJECT_DIR}/gl-container-scanning-report.json"
        "${FULL_IMAGE_NAME}"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "${FULL_IMAGE_NAME}"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "${FULL_IMAGE_NAME}"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json


build-pre-release:
  stage: build-images
  rules:
    - !reference [ .pre-release_rules, rules ]
  image: ${DOCKER_IMAGE}
  services:
    - name: ${DOCKER_SERVICE}
      variables:
        HEALTHCHECK_TCP_PORT: "2375"
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh ${DOCKER_DAEMON_OPTIONS}" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-db"
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-liquibase"
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-backend"
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/coding-box-frontend"
  before_script:
    - docker --version
    - until docker info &> /dev/null; do println "Wait until docker daemon is started ...\n" && sleep 1; done
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
    - echo "${DOCKERHUB_PASSWORD}" | docker login -u ${DOCKERHUB_USER} --password-stdin
    - docker pull --quiet ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull --quiet ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull --quiet ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull --quiet ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}
  script:
    - docker tag ${DB_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/coding-box-db:${CI_COMMIT_TAG}
    - docker tag ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/coding-box-liquibase:${CI_COMMIT_TAG}
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/coding-box-backend:${CI_COMMIT_TAG}
    - docker tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/coding-box-frontend:${CI_COMMIT_TAG}
    - docker push --quiet iqbberlin/coding-box-db:${CI_COMMIT_TAG}
    - docker push --quiet iqbberlin/coding-box-liquibase:${CI_COMMIT_TAG}
    - docker push --quiet iqbberlin/coding-box-backend:${CI_COMMIT_TAG}
    - docker push --quiet iqbberlin/coding-box-frontend:${CI_COMMIT_TAG}
  after_script:
    - docker logout ${CI_REGISTRY}
    - docker logout
